<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>DOM.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="E.EventEmitter.html">EventEmitter</a><ul class='methods'><li data-type='method'><a href="E.EventEmitter.html#emit">emit</a></li><li data-type='method'><a href="E.EventEmitter.html#on">on</a></li><li data-type='method'><a href="E.EventEmitter.html#once">once</a></li><li data-type='method'><a href="E.EventEmitter.html#removeListener">removeListener</a></li></ul></li><li><a href="E.Queue.html">Queue</a><ul class='methods'><li data-type='method'><a href="E.Queue.html#dequeue">dequeue</a></li><li data-type='method'><a href="E.Queue.html#enqueue">enqueue</a></li><li data-type='method'><a href="E.Queue.html#isEmpty">isEmpty</a></li></ul></li><li><a href="E.Stack.html">Stack</a><ul class='methods'><li data-type='method'><a href="E.Stack.html#isEmpty">isEmpty</a></li><li data-type='method'><a href="E.Stack.html#pop">pop</a></li><li data-type='method'><a href="E.Stack.html#push">push</a></li></ul></li></ul><h3>Events</h3><ul><li><a href="E.Queue.html#event:dequeue">dequeue</a></li><li><a href="E.Queue.html#event:empty">empty</a></li><li><a href="E.Queue.html#event:enqueue">enqueue</a></li><li><a href="E.Stack.html#event:empty">empty</a></li><li><a href="E.Stack.html#event:pop">pop</a></li><li><a href="E.Stack.html#event:push">push</a></li></ul><h3>Namespaces</h3><ul><li><a href="A.html">A</a><ul class='methods'><li data-type='method'><a href="A.html#.getEasing">getEasing</a></li><li data-type='method'><a href="A.html#.scrollTo">scrollTo</a></li></ul></li><li><a href="DOM.html">DOM</a><ul class='methods'><li data-type='method'><a href="DOM.html#.$">$</a></li><li data-type='method'><a href="DOM.html#.$$">$$</a></li><li data-type='method'><a href="DOM.html#.appendTo">appendTo</a></li><li data-type='method'><a href="DOM.html#.getAncestorBySelector">getAncestorBySelector</a></li><li data-type='method'><a href="DOM.html#.getBody">getBody</a></li><li data-type='method'><a href="DOM.html#.getComputed">getComputed</a></li><li data-type='method'><a href="DOM.html#.getElemDistanceFromTop">getElemDistanceFromTop</a></li><li data-type='method'><a href="DOM.html#.getElemInfo">getElemInfo</a></li><li data-type='method'><a href="DOM.html#.getPageInfo">getPageInfo</a></li><li data-type='method'><a href="DOM.html#.getSiblingsBySelector">getSiblingsBySelector</a></li><li data-type='method'><a href="DOM.html#.getViewPortInfo">getViewPortInfo</a></li><li data-type='method'><a href="DOM.html#.insertAfter">insertAfter</a></li><li data-type='method'><a href="DOM.html#.prependTo">prependTo</a></li><li data-type='method'><a href="DOM.html#.removeAll">removeAll</a></li><li data-type='method'><a href="DOM.html#.swapElements">swapElements</a></li></ul></li><li><a href="E.html">E</a><ul class='methods'><li data-type='method'><a href="E.html#.$http">$http</a></li></ul></li><li><a href="F.html">F</a><ul class='methods'><li data-type='method'><a href="F.html#.arrayOf">arrayOf</a></li><li data-type='method'><a href="F.html#.asyncAction">asyncAction</a></li><li data-type='method'><a href="F.html#.capitalize">capitalize</a></li><li data-type='method'><a href="F.html#.classOf">classOf</a></li><li data-type='method'><a href="F.html#.compose">compose</a></li><li data-type='method'><a href="F.html#.contains">contains</a></li><li data-type='method'><a href="F.html#.curry">curry</a></li><li data-type='method'><a href="F.html#.exists">exists</a></li><li data-type='method'><a href="F.html#.flatten">flatten</a></li><li data-type='method'><a href="F.html#.flip">flip</a></li><li data-type='method'><a href="F.html#.forEachObject">forEachObject</a></li><li data-type='method'><a href="F.html#.getWith">getWith</a></li><li data-type='method'><a href="F.html#.head">head</a></li><li data-type='method'><a href="F.html#.map">map</a></li><li data-type='method'><a href="F.html#.maybe">maybe</a></li><li data-type='method'><a href="F.html#.memoized">memoized</a></li><li data-type='method'><a href="F.html#.not">not</a></li><li data-type='method'><a href="F.html#.notExists">notExists</a></li><li data-type='method'><a href="F.html#.once">once</a></li><li data-type='method'><a href="F.html#.rcompose">rcompose</a></li><li data-type='method'><a href="F.html#.rcurry">rcurry</a></li><li data-type='method'><a href="F.html#.sortBy">sortBy</a></li><li data-type='method'><a href="F.html#.tail">tail</a></li><li data-type='method'><a href="F.html#.times">times</a></li><li data-type='method'><a href="F.html#.toArray">toArray</a></li><li data-type='method'><a href="F.html#.toLower">toLower</a></li><li data-type='method'><a href="F.html#.toUpper">toUpper</a></li><li data-type='method'><a href="F.html#.unary">unary</a></li><li data-type='method'><a href="F.html#.unless">unless</a></li><li data-type='method'><a href="F.html#.zip">zip</a></li></ul></li><li><a href="types.html">types</a><ul class='methods'><li data-type='method'><a href="types.html#.allowedTypes">allowedTypes</a></li><li data-type='method'><a href="types.html#.arr">arr</a></li><li data-type='method'><a href="types.html#.arrayOf">arrayOf</a></li><li data-type='method'><a href="types.html#.bool">bool</a></li><li data-type='method'><a href="types.html#.date">date</a></li><li data-type='method'><a href="types.html#.defineType">defineType</a></li><li data-type='method'><a href="types.html#.fun">fun</a></li><li data-type='method'><a href="types.html#.HTMLFragment">HTMLFragment</a></li><li data-type='method'><a href="types.html#.HTMLNode">HTMLNode</a></li><li data-type='method'><a href="types.html#.HTMLNodeList">HTMLNodeList</a></li><li data-type='method'><a href="types.html#.int">int</a></li><li data-type='method'><a href="types.html#.num">num</a></li><li data-type='method'><a href="types.html#.obj">obj</a></li><li data-type='method'><a href="types.html#.regex">regex</a></li><li data-type='method'><a href="types.html#.str">str</a></li><li data-type='method'><a href="types.html#.sym">sym</a></li></ul></li><li><a href="U.html">U</a><ul class='methods'><li data-type='method'><a href="U.html#.by">by</a></li><li data-type='method'><a href="U.html#.generateGUID">generateGUID</a></li><li data-type='method'><a href="U.html#.getCookie">getCookie</a></li><li data-type='method'><a href="U.html#.getDayName">getDayName</a></li><li data-type='method'><a href="U.html#.getDiffInDays">getDiffInDays</a></li><li data-type='method'><a href="U.html#.getIncRandomInt">getIncRandomInt</a></li><li data-type='method'><a href="U.html#.getRandomInt">getRandomInt</a></li><li data-type='method'><a href="U.html#.has">has</a></li><li data-type='method'><a href="U.html#.keys">keys</a></li><li data-type='method'><a href="U.html#.pairs">pairs</a></li><li data-type='method'><a href="U.html#.pick">pick</a></li><li data-type='method'><a href="U.html#.pluralize">pluralize</a></li><li data-type='method'><a href="U.html#.replaceAll">replaceAll</a></li><li data-type='method'><a href="U.html#.shuffle">shuffle</a></li><li data-type='method'><a href="U.html#.toCamel">toCamel</a></li><li data-type='method'><a href="U.html#.toDash">toDash</a></li><li data-type='method'><a href="U.html#.values">values</a></li></ul></li><li><a href="V.html">V</a><ul class='methods'><li data-type='method'><a href="V.html#.contains">contains</a></li><li data-type='method'><a href="V.html#.countWords">countWords</a></li><li data-type='method'><a href="V.html#.isAfterDate">isAfterDate</a></li><li data-type='method'><a href="V.html#.isAfterToday">isAfterToday</a></li><li data-type='method'><a href="V.html#.isBeforeDate">isBeforeDate</a></li><li data-type='method'><a href="V.html#.isBeforeToday">isBeforeToday</a></li><li data-type='method'><a href="V.html#.isBetween">isBetween</a></li><li data-type='method'><a href="V.html#.isColor">isColor</a></li><li data-type='method'><a href="V.html#.isComposedOf">isComposedOf</a></li><li data-type='method'><a href="V.html#.isConsecutive">isConsecutive</a></li><li data-type='method'><a href="V.html#.isCreditCard">isCreditCard</a></li><li data-type='method'><a href="V.html#.isDate">isDate</a></li><li data-type='method'><a href="V.html#.isEmailAddress">isEmailAddress</a></li><li data-type='method'><a href="V.html#.isEmpty">isEmpty</a></li><li data-type='method'><a href="V.html#.isFunc">isFunc</a></li><li data-type='method'><a href="V.html#.isHex">isHex</a></li><li data-type='method'><a href="V.html#.isHSL">isHSL</a></li><li data-type='method'><a href="V.html#.isInt">isInt</a></li><li data-type='method'><a href="V.html#.isLength">isLength</a></li><li data-type='method'><a href="V.html#.isNumber">isNumber</a></li><li data-type='method'><a href="V.html#.isOfLength">isOfLength</a></li><li data-type='method'><a href="V.html#.isPhoneNumber">isPhoneNumber</a></li><li data-type='method'><a href="V.html#.isRGB">isRGB</a></li><li data-type='method'><a href="V.html#.isString">isString</a></li><li data-type='method'><a href="V.html#.isTrimmed">isTrimmed</a></li><li data-type='method'><a href="V.html#.lacks">lacks</a></li><li data-type='method'><a href="V.html#.lessWordsThan">lessWordsThan</a></li><li data-type='method'><a href="V.html#.moreWordsThan">moreWordsThan</a></li><li data-type='method'><a href="V.html#.withoutSymbols">withoutSymbols</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">DOM.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

import { types as TYPES } from './types';
import F from './functional';

/**
 * The DOM namespace.
 * This namespace contains a set of utility functions used to access and
 * manipulate the DOM
 * @namespace DOM
 */
const DOM = {};


/**
 * Queries the DOM in pursuit of the first HTML element that matches the CSS
 * query selector.
 * @memberof DOM
 * @param {string} selector A valid CSS selector
 * @param {string} [context] The ancestor where to start the research from
 *
 * @returns {Node} An HTML node or null
 */
DOM.$ = (selector, context) => (context || document).querySelector(TYPES.str(selector));


/**
 * Queries the DOM in pursuit of all the HTML elements that match the CSS
 * query selector.
 * @memberof DOM
 * @param {string} selector A valid CSS selector
 * @param {string} [context] The ancestor where to start the research from
 *
 * @returns {NodeList} An HTML Nodelist or null
 */
DOM.$$ = (selector, context) => (context || document).querySelectorAll(TYPES.str(selector));

/**
 * Find the nearest ancestor that matches any CSS selector with respect
 * to a given element
 * @memberof DOM
 * @param {HTMLNode} elem The HTML element to start from
 * @param {string} select The ancestor where to start the research from
 *
 * @returns {Node} An HTML Node or null
 */
DOM.getAncestorBySelector = (elem, selector) => {
    // Element.matches polyfill
  if (!Object.prototype.matches) {
    if (!Element.prototype.matches) {
      Element.prototype.matches =
        Element.prototype.matchesSelector ||
        Element.prototype.mozMatchesSelector ||
        Element.prototype.msMatchesSelector ||
        Element.prototype.oMatchesSelector ||
        Element.prototype.webkitMatchesSelector ||
        function(s) {
          var matches = (this.document || this.ownerDocument).querySelectorAll(s),
            i = matches.length;
          while (i >= 0 &amp;&amp; matches.item(i) !== this) {
            --i;
          }
          return i > -1;
        };
    }
  }

  // Get closest match
  for ( ; TYPES.HTMLNode(elem) &amp;&amp; elem !== document; elem = elem.parentNode ) {
    if ( elem.matches(TYPES.str(selector)) ) {
      return elem;
    }
  }

  return null;
};


/**
 * Return document.documentElement for Chrome and Safari, document.body otherwise
 * @memberof DOM
 * @return {Node}      document.documentElement or document.body
 */
DOM.getBody = () => {
  let body;
  document.documentElement.scrollTop += 1;
  body = ( document.documentElement.scrollTop !== 0 ) ?
                            document.documentElement  :
                            document.body;
  document.documentElement.scrollTop -= 1;
  return body;
};

/**
 * Get the element's distance from the top of the page
 * @memberof DOM
 * @param  {Node}  elem  The element
 * @return {Number}      An integer representing the distance from the of the page
 */
DOM.getElemDistanceFromTop = function(elem) {
  let location = 0;
  if ( TYPES.HTMLNode(elem).offsetParent ) {
    do {
      location += elem.offsetTop;
      elem = elem.offsetParent;
    } while ( elem );
  }
  return location >= 0 ? location : 0;
};

/**
 * Get all siblings of an element (if any)
 * @memberof DOM
 * @param  {String}  selector A valid CSS selector
 * @return {Array}   An array containing the siblings
 */
DOM.getSiblingsBySelector = (selector) => {
  const siblings = [];
  const elem = document.querySelector(TYPES.str(selector));
  let sibling = elem.parentNode.firstChild;

  // Get siblings
  for ( ; sibling; sibling = sibling.nextSibling ) {
    if ( sibling.nodeType === 1 &amp;&amp; sibling !== elem ) {
      siblings.push( sibling );
    }
  }

  return siblings;
};

/**
 * Insert a new node after an existing node in the DOM
 * @memberof DOM
 * @param  {Node}  newNode The element you wish to insert
 * @param  {Node}  refNode The existing node in the DOM
 * @return {Node}  The element that was inserted
 */
DOM.insertAfter = (newNode, refNode) => {
  const p = refNode.parentNode;
  return p.insertBefore(TYPES.HTMLNode(newNode), TYPES.HTMLNode(refNode.nextSibling));
};

/**
 * Swap the position of two DOM elements
 * @memberof DOM
 * @param  {Node}  nodeA The first node
 * @param  {Node}  nodeB The second node
 * @return {Boolean}  It returns true if the swap was successful
 *                    and false otherwise
 */
DOM.swapElements = (nodeA, nodeB) => {
  const parentA = TYPES.HTMLNode(nodeA).parentNode;
  const parentB = TYPES.HTMLNode(nodeB).parentNode;
  let success = null;

  try {
    parentA.replaceChild(nodeB.cloneNode(true), nodeA);
    parentB.replaceChild(nodeA.cloneNode(true), nodeB);
    success = true;
  } catch (e) {
    success = false;
  }

  return success;
};

/**
 * Remove a number of elements from the page entirely
 * @memberof DOM
 * @param  {String}  selector A valid CSS selector
 * @return {Array}   An array containing the removed elements
 */
DOM.removeAll = (selector) => {
  const elements = Array.from(DOM.$$(selector) || []);
  elements.forEach((element) => element.parentNode.removeChild(element));
  return elements;
};

/**
 * Get the values a calculated CSS property for an element after applying
 * the active stylesheets
 * @memberof DOM
 * @param  {Node}   element The element for which to get the computed style
 * @return {CSSStyleDeclaration}
 */
DOM.getComputed = (element) => (property) => {
  return window.getComputedStyle(TYPES.HTMLNode(element), null)
               .getPropertyValue(TYPES.str(property));
};

/**
 * Get ViewPort's Info
 * @memberof DOM
 * @return {Object} An Object containing the viewport's height and width
 */
DOM.getViewPortInfo = () => {
  const body = DOM.getBody();
  const width = Math.max(body.clientWidth, window.innerWidth || 0);
  const height = Math.max(body.clientHeight, window.innerHeight || 0);
  return {
    height,
    width,
  };
};

/**
 * Get Page's Info
 * @memberof DOM
 * @return {Object} An object coontaining the page's height and width
 */
DOM.getPageInfo = () => {
  const body = document.body;
  const html = document.documentElement;
  const height = Math.max(body.scrollHeight, body.offsetHeight,
                          html.clientHeight, html.scrollHeight,
                          html.offsetHeight);
  const width = Math.max(body.scrollWidth, body.offsetWidth,
                          html.clientWidth, html.scrollWidth,
                          html.offsetWidth);

  return {
    height,
    width,
  };
};

/**
 * Get Element's Info
 * @memberof DOM
 * @return {Object} a DOMRect object which is the union of the rectangles
 *                  returned by getClientRects() for the element, i.e.,
 *                  the CSS border-boxes associated with the element.
 */
DOM.getElemInfo = (element) => TYPES.HTMLNode(element).getBoundingClientRect();

/**
 * Generate a document fragment if necessary
 * @memberof DOM
 * @access private
 * @param      {DocumentFragment | Node | Array}  children  The children to be
 *                                                           appended to the
 *                                                           document fragment
 * @return     {DocumentFragment}  A documentFragment containing the intended
 *                                 children
 */
const _generateFragment = (children = []) => {
  let frag = document.createDocumentFragment();
  const customT = TYPES.allowedTypes('DocumentFragment', 'HTMLNode');

  // Check if the provided arguments are allowed, then create the fragment
  F.arrayOf(customT)(children).forEach(child => frag.appendChild(child));

  return frag;
};

/**
 * It returns a reference to a parent Node, then you can exploit this reference
 * to add asynchronously a node, an Array of nodes, or a documentFragment
 * to the parent.
 * @memberof DOM
 * @param      {Node}   [parent=document.body]    The parent node
 * @return     {function} A function that accepts a documentFragment, a single
 *                          node, or an Array of Nodes and returns a Promise.
 *
 * @param      {DocumentFragment | Node | Array}   children  A document fragment,
 *                                                           or a single Node,
 *                                                           or an Array of Nodes
 *                                                           you wish to append
 *                                                           to the target Node.
 * @return     {Promise}  It returns a Promise that can be exploited to
 *                        understand when the action will be satisfied or not.
 *
 * @example &lt;caption>Append a new document fragment without providing a parent
 *                    node&lt;/caption>
 * let fragment = document.createDocumentFragment();
 * let node = document.createElement('DIV');
 * node.textContent = 'New Node';
 * fragment.appendChild(node);
 *
 * // By default, the parent node is document.body
 * let append = sjs.appendTo();
 * append(fragment);
 * @example &lt;caption>Append a new node to an existing Node&lt;/caption>
 * let parentNode = document.createElement('DIV');
 * parentNode.textContent = 'The parent Node';
 * // append synchronously parentNode to document.body
 * document.body.appendChild(parentNode);
 *
 * let child = document.createElement('DIV');
 * child.textContent = 'A Child Node';
 *
 * // Create a reference to the parent node
 * let appendToParent = sjs.DOM.appendTo(parentNode);
 * // append asynchronously the child Node to the parent Node
 * appendToParent(child);
 *
 * // create a new child
 * let anotherChild = document.createElement('DIV');
 * anotherChild.textContent = 'Another Child Node';
 *
 * // Using the previous reference, append the new Node to the parent Node
 * appendToParent(anotherChild);
 */
DOM.appendTo = (parent = document.body) => (...children) => {
  const fragment = _generateFragment(children);
  const append = F.asyncAction(Element.prototype.appendChild);
  return new Promise((resolve, reject) => {
    try {
      resolve(append(TYPES.HTMLNode(parent), fragment));
    } catch (e) {
      reject(e);
    }
  });
};


/**
 * It prepends asynchronously a Node, or an Array containing nodes, or a
 * documentFragment to a target Node
 * @memberof DOM
 * @param      {Node}   [target=document.body.firstChild]    The target node
 * @return     {function} A function that accepts a documentFragment, a single
 *                          node, or an Array of Nodes and returns a Promise.
 *
 * @param      {DocumentFragment | Node | Array}   children  A document fragment,
 *                                                           or a single Node,
 *                                                           or an Array of Nodes
 *                                                           you wish to prepend
 *                                                           to the target Node.
 * @return     {Promise}  It returns a Promise that can be exploited to
 *                        understand when the action will be satisfied or not.
 *
 */
DOM.prependTo = (target = document.body.firstChild) => (...children) => {
  const fragment = _generateFragment(children);
  const prepend = F.asyncAction(Element.prototype.insertBefore);
  return new Promise((resolve, reject) => {
    try {
      resolve(prepend(TYPES.HTMLNode(target), fragment, target.firstChild));
    } catch (e) {
      reject(e);
    }
  });

};

// export public functions
export default { ...DOM };</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.4</a> on Fri Sep 01 2017 13:02:50 GMT+0200 (CEST) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
